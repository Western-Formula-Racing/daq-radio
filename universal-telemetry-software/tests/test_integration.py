"""
Integration tests for the Universal Telemetry Software.

Tests the complete data flow:
1. Car generates simulated CAN data
2. Car sends via UDP to base
3. Base receives and publishes to Redis
4. Base serves data via WebSocket
5. Packet drops are detected
6. TCP retransmission recovers missing packets
"""
import pytest
import asyncio
import time
import json
import logging
from .test_helpers import (
    RedisHelper,
    WebSocketHelper,
    DockerHelper,
    NetworkHelper,
    wait_for_service,
    check_http_endpoint
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Container names from docker-compose.test.yml
CAR_CONTAINER = "daq-car"
BASE_CONTAINER = "daq-base"
CAR_REDIS_CONTAINER = "daq-car-redis"
BASE_REDIS_CONTAINER = "daq-base-redis"

# Service endpoints
REDIS_HOST = "localhost"
REDIS_PORT = 6379
WS_URL = "ws://localhost:9080"
STATUS_URL = "http://localhost:8080"


@pytest.fixture(scope="module")
def docker():
    """Docker helper fixture."""
    return DockerHelper()


@pytest.fixture(scope="module")
def redis_helper():
    """Redis helper fixture."""
    helper = RedisHelper(host=REDIS_HOST, port=REDIS_PORT)
    yield helper
    helper.close()


class TestContainerHealth:
    """Test that all containers start and are healthy."""
    
    def test_car_container_running(self, docker):
        """Verify car container is running."""
        assert docker.is_container_running(CAR_CONTAINER), \
            f"{CAR_CONTAINER} is not running"
        logger.info(f"✓ {CAR_CONTAINER} is running")
    
    def test_base_container_running(self, docker):
        """Verify base container is running."""
        assert docker.is_container_running(BASE_CONTAINER), \
            f"{BASE_CONTAINER} is not running"
        logger.info(f"✓ {BASE_CONTAINER} is running")
    
    def test_redis_containers_running(self, docker):
        """Verify Redis containers are running."""
        assert docker.is_container_running(CAR_REDIS_CONTAINER), \
            f"{CAR_REDIS_CONTAINER} is not running"
        assert docker.is_container_running(BASE_REDIS_CONTAINER), \
            f"{BASE_REDIS_CONTAINER} is not running"
        logger.info("✓ Both Redis containers are running")
    
    def test_redis_connectivity(self, redis_helper):
        """Verify Redis is accessible."""
        assert wait_for_service(redis_helper.ping, timeout=10), \
            "Redis is not accessible"
        logger.info("✓ Redis is accessible")
    
    def test_car_role_detection(self, docker):
        """Verify car detected its role correctly."""
        logs = docker.get_container_logs(CAR_CONTAINER, tail=100)
        assert "Role explicitly set to: car" in logs or "Auto-detected Role: car" in logs, \
            "Car did not detect role correctly"
        logger.info("✓ Car role detected correctly")
    
    def test_base_role_detection(self, docker):
        """Verify base detected its role correctly."""
        logs = docker.get_container_logs(BASE_CONTAINER, tail=100)
        assert "Role explicitly set to: base" in logs or "Auto-detected Role: base" in logs, \
            "Base did not detect role correctly"
        logger.info("✓ Base role detected correctly")


class TestUDPDataFlow:
    """Test UDP data transmission from car to base."""
    
    def test_car_sending_udp(self, docker):
        """Verify car is sending UDP packets."""
        # Give car time to start sending
        time.sleep(3)
        logs = docker.get_container_logs(CAR_CONTAINER, tail=50)
        # Car should have CAN reader and UDP sender running
        assert "CAN Reader started" in logs or "Starting simulation mode" in logs, \
            "Car CAN reader/simulator not started"
        logger.info("✓ Car is generating CAN data")
    
    def test_base_receiving_udp(self, docker):
        """Verify base is receiving UDP packets."""
        time.sleep(5)  # Wait for packets to flow
        logs = docker.get_container_logs(BASE_CONTAINER, tail=100)
        assert "Initial sequence:" in logs, \
            "Base has not received initial UDP packet"
        logger.info("✓ Base is receiving UDP packets")


class TestRedisPublishing:
    """Test that base publishes CAN messages to Redis."""
    
    def test_can_messages_published(self, redis_helper):
        """Verify CAN messages are published to Redis."""
        redis_helper.subscribe('can_messages')
        
        # Wait for a message
        msg = redis_helper.get_message(timeout=10)
        assert msg is not None, "No CAN messages received from Redis"
        
        # Verify message format
        assert isinstance(msg, list), "CAN message should be a list"
        assert len(msg) > 0, "CAN message list should not be empty"
        
        # Check first message structure
        first_msg = msg[0]
        assert 'time' in first_msg, "Message missing 'time' field"
        assert 'canId' in first_msg, "Message missing 'canId' field"
        assert 'data' in first_msg, "Message missing 'data' field"
        assert isinstance(first_msg['data'], list), "Data should be a list"
        assert len(first_msg['data']) == 8, "CAN data should be 8 bytes"
        
        logger.info(f"✓ Received valid CAN message: {first_msg}")
    
    def test_system_stats_published(self, redis_helper):
        """Verify system stats are published to Redis."""
        redis_helper.subscribe('system_stats')
        
        # Wait for stats message
        msg = redis_helper.get_message(timeout=10)
        assert msg is not None, "No system stats received from Redis"
        
        # Verify stats format
        assert isinstance(msg, dict), "System stats should be a dict"
        assert 'received' in msg, "Stats missing 'received' field"
        assert 'missing' in msg, "Stats missing 'missing' field"
        assert 'recovered' in msg, "Stats missing 'recovered' field"
        
        logger.info(f"✓ Received system stats: {msg}")


class TestWebSocketBroadcast:
    """Test WebSocket broadcasting to PECAN dashboard."""
    
    @pytest.mark.asyncio
    async def test_websocket_connection(self):
        """Verify WebSocket server is accessible."""
        ws_helper = WebSocketHelper(WS_URL)
        
        # Wait for WebSocket to be ready
        await asyncio.sleep(2)
        
        try:
            await ws_helper.connect()
            logger.info("✓ WebSocket connection established")
        finally:
            await ws_helper.close()
    
    @pytest.mark.asyncio
    async def test_websocket_receives_data(self):
        """Verify WebSocket receives CAN messages."""
        ws_helper = WebSocketHelper(WS_URL)
        
        try:
            await ws_helper.connect()
            
            # Wait for a message
            msg = await ws_helper.receive_message(timeout=10)
            assert msg is not None, "No message received via WebSocket"
            
            # WebSocket should forward the same format as Redis
            assert isinstance(msg, list), "WebSocket message should be a list"
            if len(msg) > 0:
                first_msg = msg[0]
                assert 'time' in first_msg, "Message missing 'time' field"
                assert 'canId' in first_msg, "Message missing 'canId' field"
                assert 'data' in first_msg, "Message missing 'data' field"
            
            logger.info(f"✓ WebSocket received CAN data: {len(msg)} messages")
        finally:
            await ws_helper.close()


class TestStatusHTTPServer:
    """Test the status monitoring HTTP server."""
    
    def test_status_page_accessible(self):
        """Verify status page loads."""
        assert wait_for_service(
            lambda: check_http_endpoint(STATUS_URL),
            timeout=10
        ), "Status page is not accessible"
        logger.info("✓ Status page is accessible")
    
    def test_status_page_content(self):
        """Verify status page has expected content."""
        import requests
        response = requests.get(STATUS_URL, timeout=5)
        assert response.status_code == 200
        
        content = response.text
        assert "DAQ Base Station Status" in content or "Status" in content, \
            "Status page missing expected title"
        logger.info("✓ Status page has valid content")


class TestPacketDropAndRecovery:
    """Test packet drop detection and TCP retransmission."""
    
    def test_forced_packet_drop(self, docker, redis_helper):
        """
        Force packet drops and verify base detects missing sequences.
        
        This test:
        1. Monitors current sequence numbers
        2. Drops UDP packets using iptables
        3. Verifies base detects missing packets
        4. Waits for TCP retransmission
        5. Verifies packets are recovered
        """
        # Subscribe to can_messages to monitor flow
        redis_helper.subscribe('can_messages')
        
        # Get initial messages to establish baseline
        logger.info("Establishing baseline data flow...")
        for _ in range(3):
            msg = redis_helper.get_message(timeout=5)
            assert msg is not None, "No baseline messages received"
        
        # Now introduce packet drops on the car container
        # Drop approximately 20% of UDP packets on port 5005
        logger.info("Introducing packet drops...")
        success = NetworkHelper.drop_udp_packets(CAR_CONTAINER, 5005, count=20)
        
        if not success:
            logger.warning("Could not configure packet drops (may need privileged mode)")
            pytest.skip("Packet drop test requires privileged container")
        
        try:
            # Wait for packets to be dropped and detected
            time.sleep(15)  # Wait longer than MISSING_CHECK_INTERVAL (10s)
            
            # Check base logs for missing packet detection
            logs = docker.get_container_logs(BASE_CONTAINER, tail=200)
            
            # Look for evidence of missing packets or resend requests
            has_missing = "Gap detected" in logs or "missing" in logs.lower()
            has_resend = "Requesting resend" in logs or "Resend request" in logs
            
            if has_missing:
                logger.info("✓ Base detected missing packets")
            
            if has_resend:
                logger.info("✓ Base requested TCP retransmission")
            
            # At minimum, we should see the system handling the packet drops
            # Either by detecting gaps or attempting recovery
            assert has_missing or has_resend, \
                "No evidence of packet drop detection or recovery in logs"
            
        finally:
            # Clean up iptables rules
            NetworkHelper.clear_packet_drops(CAR_CONTAINER)
            logger.info("Cleared packet drop rules")
    
    def test_tcp_retransmission_server(self, docker):
        """Verify car has TCP retransmission server running."""
        logs = docker.get_container_logs(CAR_CONTAINER, tail=100)
        # The TCP server starts as part of run_car
        # We can verify it's in the logs or check if port 5006 is listening
        
        # Check if TCP server is listening
        output = docker.exec_in_container(
            CAR_CONTAINER,
            ['sh', '-c', 'netstat -ln | grep 5006 || ss -ln | grep 5006']
        )
        
        assert '5006' in output, "TCP retransmission server not listening on port 5006"
        logger.info("✓ TCP retransmission server is running")
    
    def test_recovery_stats(self, redis_helper):
        """
        Verify recovery statistics are tracked.
        
        After packet drops and recovery, the system_stats should show
        recovered packets.
        """
        redis_helper.subscribe('system_stats')
        
        # Collect several stats messages
        stats_samples = []
        for _ in range(5):
            msg = redis_helper.get_message(timeout=3)
            if msg:
                stats_samples.append(msg)
        
        assert len(stats_samples) > 0, "No system stats received"
        
        # Check that stats have the expected fields
        for stats in stats_samples:
            assert 'received' in stats
            assert 'missing' in stats
            assert 'recovered' in stats
        
        logger.info(f"✓ System stats tracking: {stats_samples[-1]}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
