/**
 * Telemetry DataStore
 * 
 * A singleton in-browser data buffer for live telemetry from WebSocket.
 * Provides a single source of truth for "what's the latest value?" and 
 * "what happened in the last X seconds?" for each CAN message ID.
 */

// Type definitions matching the canProcessor output
export interface TelemetrySample {
  timestamp: number; // timestamp in ms (Date.now() when received)
  msgID: string; // CAN ID as string
  messageName: string; // Human-readable message name from DBC
  data: {
    [signalName: string]: {
      sensorReading: number;
      unit: string;
    };
  };
  rawData: string; // Original payload bytes "00 01 02 ..."
}

// Internal storage structure
interface MessageBuffer {
  samples: TelemetrySample[];
  lastUpdated: number;
}

// Listener callback type
type Listener = (msgID?: string) => void;

/**
 * DataStore Class - Singleton Pattern
 */
class DataStore {
  // Internal storage: msgID -> array of samples (chronological order)
  private buffer: Map<string, MessageBuffer>;
  
  // Retention window in milliseconds (default: 30 seconds)
  private retentionWindowMs: number;
  
  // Pub/sub listeners
  private listeners: Set<Listener>;
  
  // Singleton instance
  private static instance: DataStore | null = null;

  private constructor(retentionWindowMs: number = 30000) {
    this.buffer = new Map();
    this.retentionWindowMs = retentionWindowMs;
    this.listeners = new Set();
  }

  /**
   * Get the singleton instance
   */
  public static getInstance(retentionWindowMs?: number): DataStore {
    if (!DataStore.instance) {
      DataStore.instance = new DataStore(retentionWindowMs);
    } else if (typeof retentionWindowMs === 'number') {
      DataStore.instance.setRetentionWindow(retentionWindowMs);
    }
    return DataStore.instance;
  }

  /**
   * Ingest a new CAN message into the data store
   * @param message - Telemetry sample to ingest
   */
  public ingestMessage(message: {
    msgID: string;
    messageName: string;
    data: {
      [signalName: string]: {
        sensorReading: number;
        unit: string;
      };
    };
    rawData: string;
    timestamp?: number;
  }): void {
    // Fix for old timestamps from recorded data
    // If timestamp is more than 1 hour old, use current time
    let timestamp = message.timestamp || Date.now();
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    if (timestamp < oneHourAgo) {
      timestamp = Date.now();
    }
    
    const msgID = message.msgID;

    // Round sensor readings to 3 decimal places for cleaner display
    const roundedData = { ...message.data };
    Object.keys(roundedData).forEach((key) => {
      const signal = roundedData[key];
      if (signal && typeof signal.sensorReading === 'number') {
        roundedData[key] = {
          ...signal,
          sensorReading: Math.round(signal.sensorReading * 1000) / 1000,
        };
      }
    });

    // Create the sample
    const sample: TelemetrySample = {
      timestamp,
      msgID,
      messageName: message.messageName,
      data: roundedData,
      rawData: message.rawData,
    };

    // Get or create buffer for this msgID
    if (!this.buffer.has(msgID)) {
      this.buffer.set(msgID, {
        samples: [],
        lastUpdated: timestamp,
      });
    }

    const messageBuffer = this.buffer.get(msgID)!;
    
    // Add new sample
    messageBuffer.samples.push(sample);
    messageBuffer.lastUpdated = timestamp;

    // Prune old samples (rolling window)
    this.pruneOldSamples(msgID);

    // Notify all subscribers
    this.notifyAll(msgID);
  }

  /**
   * Prune samples older than the retention window for a specific msgID
   * @param msgID - CAN message ID to prune
   */
  private pruneOldSamples(msgID: string): void {
    const messageBuffer = this.buffer.get(msgID);
    if (!messageBuffer) return;

    const cutoffTime = Date.now() - this.retentionWindowMs;
    
    // Filter out samples older than cutoff
    messageBuffer.samples = messageBuffer.samples.filter(
      (sample) => sample.timestamp >= cutoffTime
    );

    // If no samples left, we could optionally remove the msgID entry
    // For now, we'll keep it to preserve the messageName mapping
  }

  /**
   * Get the latest sample for a specific msgID
   * @param msgID - CAN message ID
   * @returns Most recent sample or undefined if not found
   */
  public getLatest(msgID: string): TelemetrySample | undefined {
    const messageBuffer = this.buffer.get(msgID);
    if (!messageBuffer || messageBuffer.samples.length === 0) {
      return undefined;
    }

    // Return the last sample (newest)
    return messageBuffer.samples[messageBuffer.samples.length - 1];
  }

  /**
   * Get all samples for a msgID within a time window
   * @param msgID - CAN message ID
   * @param windowMs - Time window in milliseconds (default: all available)
   * @returns Array of samples within the time window
   */
  public getHistory(msgID: string, windowMs?: number): TelemetrySample[] {
    const messageBuffer = this.buffer.get(msgID);
    if (!messageBuffer) {
      return [];
    }

    // If no window specified, return all samples
    if (windowMs === undefined) {
      return [...messageBuffer.samples];
    }

    // Filter samples within the time window
    const cutoffTime = Date.now() - windowMs;
    return messageBuffer.samples.filter(
      (sample) => sample.timestamp >= cutoffTime
    );
  }

  /**
   * Get the latest value for a specific signal from a specific message
   * @param msgID - CAN message ID
   * @param signalName - Signal name to retrieve
   * @returns Signal data with reading and unit, or undefined if not found
   */
  public getSignal(msgID: string, signalName: string): {
    sensorReading: number;
    unit: string;
  } | undefined {
    const latest = this.getLatest(msgID);
    if (!latest || !latest.data[signalName]) {
      return undefined;
    }

    return latest.data[signalName];
  }

  /**
   * Get all msgIDs currently in the buffer
   * @returns Array of message IDs
   */
  public getAllMessageIds(): string[] {
    return Array.from(this.buffer.keys());
  }

  /**
   * Get all latest samples (one per msgID)
   * @returns Map of msgID to latest sample
   */
  public getAllLatest(): Map<string, TelemetrySample> {
    const result = new Map<string, TelemetrySample>();
    
    for (const [msgID, messageBuffer] of this.buffer.entries()) {
      if (messageBuffer.samples.length > 0) {
        result.set(msgID, messageBuffer.samples[messageBuffer.samples.length - 1]);
      }
    }
    
    return result;
  }

  /**
   * Subscribe to data updates
   * @param listener - Callback function to be called on updates
   * @returns Unsubscribe function
   */
  public subscribe(listener: Listener): () => void {
    this.listeners.add(listener);
    
    // Return unsubscribe function
    return () => {
      this.listeners.delete(listener);
    };
  }

  /**
   * Notify all subscribers of a data update
   * @param msgID - Optional message ID that was updated
   */
  private notifyAll(msgID?: string): void {
    this.listeners.forEach((listener) => {
      try {
        listener(msgID);
      } catch (error) {
        console.error('Error in DataStore listener:', error);
      }
    });
  }

  /**
   * Clear all data from the store
   */
  public clear(): void {
    this.buffer.clear();
    this.notifyAll();
  }

  /**
   * Clear data for a specific msgID
   * @param msgID - CAN message ID to clear
   */
  public clearMessage(msgID: string): void {
    this.buffer.delete(msgID);
    this.notifyAll(msgID);
  }

  /**
   * Update the retention window
   * @param windowMs - New retention window in milliseconds
   */
  public setRetentionWindow(windowMs: number): void {
    if (windowMs === this.retentionWindowMs) {
      return;
    }

    this.retentionWindowMs = windowMs;

    // Prune all messages with new window
    for (const msgID of this.buffer.keys()) {
      this.pruneOldSamples(msgID);
    }

    // Notify subscribers since data might have been pruned
    this.notifyAll();
  }

  /**
   * Get current retention window
   * @returns Retention window in milliseconds
   */
  public getRetentionWindow(): number {
    return this.retentionWindowMs;
  }

  /**
   * Get statistics about the data store
   * @returns Object with stats
   */
  public getStats(): {
    totalMessages: number;
    totalSamples: number;
    oldestSample: number | null;
    newestSample: number | null;
    memoryEstimateMB: number;
  } {
    let totalSamples = 0;
    let oldestSample: number | null = null;
    let newestSample: number | null = null;

    for (const messageBuffer of this.buffer.values()) {
      totalSamples += messageBuffer.samples.length;
      
      if (messageBuffer.samples.length > 0) {
        const firstTimestamp = messageBuffer.samples[0].timestamp;
        const lastTimestamp = messageBuffer.samples[messageBuffer.samples.length - 1].timestamp;
        
        if (oldestSample === null || firstTimestamp < oldestSample) {
          oldestSample = firstTimestamp;
        }
        
        if (newestSample === null || lastTimestamp > newestSample) {
          newestSample = lastTimestamp;
        }
      }
    }

    // Rough memory estimate (very approximate)
    const avgSampleSize = 200; // bytes per sample (rough estimate)
    const memoryEstimateMB = (totalSamples * avgSampleSize) / (1024 * 1024);

    return {
      totalMessages: this.buffer.size,
      totalSamples,
      oldestSample,
      newestSample,
      memoryEstimateMB: Math.round(memoryEstimateMB * 100) / 100,
    };
  }
}

// Export singleton instance
export const dataStore = DataStore.getInstance();

// Export class for testing purposes
export { DataStore };